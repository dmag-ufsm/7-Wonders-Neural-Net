# -*- coding: utf-8 -*-
"""nn7Wonders.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h18obu_a-7kvfGuIwBdOSNd3u5mc8HcX
"""

import torch 
import torch.nn as nn 
import torch.nn.functional as F
from pathlib import Path

## Define network
class Net(nn.Module):
  def __init__(self, input_size, hidden_size, num_classes):
    super(Net, self).__init__()
    self.net = nn.Sequential(
        nn.Linear(input_size, hidden_size),
        nn.ReLU(),
        nn.Linear(hidden_size, num_classes)
    )
  
  def forward(self, x):
    x = self.net(x)
    return x

batch_size, input_size, hidden_size, num_classes = 64, 21, 42, 21

## Instantiating network, passing size of first, second, third layer respectively
model = Net(input_size, hidden_size, num_classes)
print(model)

## TODO: load game dataset for training

# Create random tensors for tests
x = torch.randn(batch_size, input_size)
y = torch.randn(batch_size, num_classes)

print(x)
print(y)

## set function to calculate error
criterion = torch.nn.MSELoss(reduction='sum')
## optimization method
optimizer = torch.optim.SGD(model.parameters(), lr=1e-4)

## train loop
for t in range(500):
  out = model(x)

  # compute and print loss
  loss = criterion(out, y)
  if t % 100 == 99:
    print(t, loss.item())
  
  # zero gradients, perform 
  optimizer.zero_grad()

  # backpropagation
  loss.backward()
  optimizer.step()

print(model.state_dict())

## this only works with python >= 3.5
## create models folder if not exists
Path("./models").mkdir(parents=True, exist_ok=True)

## save model in file
PATH = './models/seven_net.pth'
torch.save(model.state_dict(), PATH)